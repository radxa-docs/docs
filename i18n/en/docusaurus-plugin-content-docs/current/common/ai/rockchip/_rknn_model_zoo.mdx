RKNN Model Zoo is built on top of the RKNPU SDK toolchain and provides deployment examples for many mainstream algorithms. It covers the full workflow of exporting RKNN models and performing inference using both the Python API and the C API.

RKNN Model Zoo depends on **RKNN-Toolkit2** for model conversion. When compiling C API demos, you also need the corresponding cross-compilation toolchain.

## Clone the Repository

<NewCodeBlock tip="X86 Linux PC" type="PC">

```bash
mkdir RKSDK && cd RKSDK
git clone -b v2.3.2 https://github.com/airockchip/rknn_model_zoo.git
```

</NewCodeBlock>

## Repository Structure

```bash
./
├── 3rdparty
├── asset
├── build
├── build-android.sh
├── build-linux.sh
├── datasets
├── docs
├── examples # example directory
│   ├── clip
│   ├── deeplabv3
│   ├── lite_transformer
│   ├── LPRNet
│   ├── mms_tts
│   ├── mobilenet
│   ├── mobilesam
│   ├── PPOCR
│   ├── ppseg
│   ├── ppyoloe
│   ├── resnet
│   ├── RetinaFace
│   ├── wav2vec2
│   ├── whisper
│   ├── yamnet
│   ├── yolo11
│   ├── yolov10
│   ├── yolov5
│   ├── yolov5_seg
│   ├── yolov6
│   ├── yolov7
│   ├── yolov8
│   ├── yolov8_obb
│   ├── yolov8_pose
│   ├── yolov8_seg
│   ├── yolo_world
│   ├── yolox
│   └── zipformer
├── FAQ_CN.md
├── FAQ.md
├── install
├── LICENSE
├── py_utils
│   ├── coco_utils.py
│   ├── __init__.py
│   ├── onnx_executor.py
│   ├── pytorch_executor.py
│   └── rknn_executor.py
├── README_CN.md
├── README.md
├── scaling_frequency.sh
└── utils
    ├── audio_utils.c
    ├── audio_utils.h
    ├── CMakeLists.txt
    ├── common.h
    ├── file_utils.c
    ├── file_utils.h
    ├── font.h
    ├── image_drawing.c
    ├── image_drawing.h
    ├── image_utils.c
    └── image_utils.h
```

## Basic Usage Flow

### C API

Use the `build-linux.sh` script in the repository root to compile the C demos.

If you want to build executables on an x86_64 host that run on an arm64 target device, you must first download a cross-compilation toolchain.

Download link: [Cross-compilation toolchain](https://developer.arm.com/-/media/files/downloads/gnu/11.2-2022.02/binrel/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu.tar.xz?rev=33c6e30e5ac64e6dba8f0431f2c35f1b&revision=33c6e30e-5ac6-4e6d-ba8f-0431f2c35f1b&hash=632C6C0BD43C3E4B59CA8A09A7055D30).

After the download is complete, extract the archive.

Before using the build script, you need to export the compiler path to an environment variable so that the script can find the downloaded cross toolchain.

<NewCodeBlock tip="X86 Linux PC" type="PC">

```bash
export GCC_COMPILER=/path/to/your/gcc/bin/aarch64-linux-gnu
```

</NewCodeBlock>

Basic usage of the script:

<NewCodeBlock tip="X86 Linux PC" type="PC">

```bash
./build-linux.sh -t <target> -a <arch> -d <build_demo_name> [-b <build_type>] [-m]
    -t : target (rk356x/rk3588)
    -a : arch (aarch64)
    -d : demo name
    -b : build_type(Debug/Release)
    -m : enable address sanitizer, build_type need set to Debug
Note: `rk356x` represents rk3562/rk3566/rk3568.

# Example: build the YOLOv5 demo for RK3566:
./build-linux.sh -t rk356x -a aarch64 -d yolov5
```

</NewCodeBlock>

### Python API

Activate the virtual environment. After the model has been converted to RKNN format, enter the target example directory and run the corresponding Python script directly.

For example, to run the YOLOv5 demo on an RK3566 target:

<NewCodeBlock tip="Device" type="device">

```bash
conda activate rknn
cd examples/yolov5/python/
python3 yolov5.py --target rk356x --img_show
```

</NewCodeBlock>
